# ELF 정적 분석기

## 1.프로젝트 개요
본 프로젝트는 GoLang으로 작성된 ELF 바이너리 정적 분석 도구입니다. 리눅스 실행파일을 입력받아 해당 파일이 런타임에 의존하는 동적 심볼 목록을 추출합니다.

이후 추출된 심볼 목록을 알려진 시스템콜 목록과 비교하여 바이너리파일이 잠재적으로 호출할 수 있는 시스템 콜을 식별하고, 식별된 시스템콜 목록을 JSON형식으로 출력하는 것을 목적으로 합니다.

## 2. 주요 기능
* **ELF 파일 파싱** : GoLang의 debug/elf 패키지를 사용하여 실행파일의 .dynsym섹션등을 분석

(어느 섹션이 주요한 섹션이더라 여기에 적기)
  
*  **동적 심볼 추출** : 바이너리가 런타임에 의존하는 동적 심볼 목록을 추출
  
*  **시스템 콜 필터링** : 추출된 심볼 목록중, 시스템콜을 호출하는 심볼을 추출

* **동적 시스템콜 목록 확보** : man 2 syscalls 출력을 파싱하여 시스템콜 목록을 동적으로 생성합니다.
   
*  **정적 목록 제공**  : man 사용불가할 경우 미리 정의된 시스템콜 이름을 직접 추가할 수 있습니다

*  **JSON 형식 출력** : 시스템콜 목록과 추출된 심볼을 비교하여 시스템콜을 호출하는 심볼을 식별하고, 해당 실행파일이 호출하는 시스템콜 목록을 JSON 배열 형식으로 표준 출력합니다.
   
## 3. 요구사항
* **GoLang** : Go 1.24.3 이상 (go.mod 기준)
* **운영체제** : Linux
* **man** : man명령어 및 manpages-dev 실행가능(불가하다면 정적으로 목록 작성 가능)
* **Go 의존성** : github.com/knightsc/gapstone GoLang의 디스어셈블러  (현재 main.go에서는 관련 기능이 주석 처리되어 있으나 어셈블리 분석시 asmanalysis 패키지에서 사용)

## 4. 사용 방법
#### 1. (선택) 바이너리 빌드
```bash
go build ./cmd/static-analyzer
```
를 이용하여 go소스코드를 바이너리로 빌드가능(생략가능)

#### 2. 분석기 실행
go run으로 빌드와 실행을 동시에 하거나, 빌드된 바이너리파일 실행

go run 으로 빌드와 실행 
```bash
go run ./cmd/static-analyzer/main.go <분석할_ELF_파일_경로>
```

1단계에서 빌드된 바이너리 실행
```bash
./static-analyzer <분석할_ELF_파일_경로>
```

## 5. 프로젝트 구조
```
.
├── cmd/static-analyzer/
│   └── main.go             # (메인) 프로그램 엔트리 포인트, 인자 처리 및 분석 모듈 호출
├── pkg/
│   ├── analyzer/
│   │   ├── elf_parser.go     # (모듈) ELF 파일 파싱 및 심볼 추출 로직
│   │   └── syscall_filter.go # (모듈) man 페이지 파싱, 동적/정적 시스템 콜 목록 생성 및 필터링
│   └── asmanalysis/
│       └── syscall_finder.go # (모듈) .text 섹션의 어셈블리를 분석하여 syscall 탐지 (실험적)
├── go.mod                    # Go 모듈 정의
├── go.sum                    # 의존성 록 파일
└── .vscode/
    └── launch.json           # VSCode 디버깅 설정
```

## 6. 향후 개선 사항

어셈블리코드를 직접 분석가능합니다(대부분의 elf파일은 코드 난독화로 인해 분석에 난항)

## 7. 라이센스

